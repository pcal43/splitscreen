apply plugin: 'java'
apply plugin: 'net.neoforged.moddev'
apply plugin: 'com.modrinth.minotaur'
apply plugin: 'net.darkhax.curseforgegradle'

buildscript {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        // This has to be on the classpath so we can delcare a task with it below;
        // this is the only way to do that in the applied script.
        // The new curseforgegradle plugin does not have a DSL config.
        classpath "net.darkhax.curseforgegradle:CurseForgeGradle:${curseforgegradle_plugin_version}"
    }
}

base {
    archivesName = "${project.archives_base_name}-neoforge"
}

// groovy
project.plugins.withId('net.neoforged.moddev') {
    neoForge {
        version = project.neoforge_version

        runs {
            client {
                type = "client"
                gameDirectory = file("${project.projectDir}/run")
            }
            server {
                type = "server"
                gameDirectory = file("${project.projectDir}/run")
            }
        }
        mods {
            mobfilter {
                sourceSet sourceSets.main
                // Also include common module for resources and classes
                sourceSet project(":common").sourceSets.main
            }
        }
    }
}

dependencies {
    // Use the compiled common jar - it has proper Mojang mappings from Loom
    implementation project(":common")
    compileOnly "org.spongepowered:mixin:${project.spongepowered_version}"
    annotationProcessor "org.spongepowered:mixin:${project.spongepowered_version}:processor"
}

processResources {
    inputs.property "version", project.mod_version
    filesMatching("META-INF/neoforge.mods.toml") {
        filter { line ->
            line.replace('${version}', project.mod_version.toString())
        }
    }
}

project.afterEvaluate {
    sourceSets.named('main').configure { sourceSet ->
        sourceSet.java.srcDir(project(":common").file("src/main/java"))
        sourceSet.resources.srcDir(project(":common").file("src/main/resources"))
    }
}

jar {
    from("LICENSE") {
        rename { "${it}_${archivesName}"}
    }

    // Include common classes directly in the jar
    from(project(":common").sourceSets.main.output) {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }
}


// Publishing configuration
modrinth {
    token = System.getenv("MODRINTH_TOKEN")
    projectId = "${project.modrinth_projectId}"
    versionNumber = project.mod_version
    versionType = "release"
    uploadFile = jar
    changelog = "<p><a href='${project.github_projectUrl}/releases/tag/${project.mod_version}'>${project.github_projectUrl}/releases/tag/${project.mod_version}</a></p>"
    gameVersions = ["${project.minecraft_version}"]
    loaders = ["neoforge"]
}

import net.darkhax.curseforgegradle.TaskPublishCurseForge
tasks.register('publishCurseForge', TaskPublishCurseForge) {
    // API Key from environment or fallback
    apiToken = System.getenv("CURSEFORGE_TOKEN") ?: 'CURSEFORGE_TOKEN NOT_SET'

    def mainFile = upload(project.curseforge_projectId, jar)
    mainFile.releaseType = "release"
    mainFile.changelog = "${project.github_projectUrl}/releases/tag/${project.mod_version}"
    mainFile.changelogType = "markdown"
    mainFile.addGameVersion(project.minecraft_version)
    mainFile.addModLoader("NeoForge")
    // Ensure remapJar is finished before this runs
    dependsOn(jar)
}

